#include "text.h"void initText(Text_t* text) {    text->capacity = 10;    text->sentences = (Sentence_t**)malloc(text->capacity * sizeof(Sentence_t*));    text->size = 0;}void reserveTextMemory(Text_t* text, size_t newCapacity) {    text->sentences = (Sentence_t**)(realloc(text->sentences, newCapacity * sizeof(Sentence_t*)));    text->capacity = newCapacity;}void addSentenceToText(Text_t* text, Sentence_t* sentence) {    if (text->size == text->capacity) {        reserveTextMemory(text, text->capacity * 2);    }    text->sentences[text->size] = sentence;    text->size++;}void readText(Text_t* text, FILE *file) {    while (true) {        Sentence_t *sentence = (Sentence_t *) malloc(sizeof(Sentence_t));        initSentence(sentence);        readSentence(sentence, file);        updateSentenceProduct(sentence);        if (sentence->size == 0 || isTerminalSymbol(sentence->symbols[sentence->size - 1])) {            freeSentence(sentence);            break;        }        addSentenceToText(text, sentence);    }}int cmp(const void* a, const void* b){    return ((*((Sentence_t**)a))->product - (*((Sentence_t**)b))->product);}void sortText(Text_t* text){    qsort(text->sentences, text->size, sizeof(Sentence_t*), (__compar_fn_t) cmp);}void printText(Text_t *text, FILE *file) {    for (size_t i = 0; i < text->size; i++) {        fwprintf(file,L"%ls ", text->sentences[i]->symbols);    }}void deleteSentences(Text_t* text, size_t ind) {    freeSentence(text->sentences[ind]);    for (size_t i = ind; i < text->size - 1; i++) {        text->sentences[i] = text->sentences[i+1];    }    text->size--;}void processingText(Text_t* text) {    for (size_t i = 0;  i < text->size; i++) {        if (!foundInSentence(text->sentences[i])) {            deleteSentences(text, i);            i--;        }    }}bool isWordInSentence(Sentence_t* sentence, Sentence_t* word){    int count = 0;    if (word->size > sentence->size)        return false;    for(size_t i = 0; i < sentence->size - word->size; i++){        size_t j = 0;        for(j = 0; j < word->size; j++){            if(sentence->symbols[i+j] != word->symbols[j]) {                break;            }        }        if(j == word->size){            count++;        }    }    return count > 1;}void skipSeparators(size_t* j, Text_t* text, const size_t* i) {    do {        (*j)++;    } while(*j < text->sentences[*i]->size && (isEndingOfSentence(text->sentences[*i]->symbols[*j]) || isSentenceSeparator(text->sentences[*i]->symbols[*j])));}Sentence_t* getWord(Text_t* text, size_t* i, size_t* j){    Sentence_t *word = (Sentence_t *) malloc(sizeof(Sentence_t));    initSentence(word);    while(*i < text->size) {        if(*j != 0)            skipSeparators(j, text, i);        if(*j >= text->sentences[*i]->size){            (*i)++;            (*j = 0);        }        while(*i < text->size && *j < text->sentences[*i]->size && !isEndingOfSentence(text->sentences[*i]->symbols[*j]) && !isSentenceSeparator(text->sentences[*i]->symbols[*j])){            addSymbolToSentence(word, text->sentences[*i]->symbols[*j]);            (*j)++;            if(*j >= text->sentences[*i]->size || isEndingOfSentence(text->sentences[*i]->symbols[*j]) || isSentenceSeparator(text->sentences[*i]->symbols[*j])){                return word;            }        }        (*i)++;        (*j) = 0;    }    return word;}bool check(Text_t *text, Sentence_t *word, int index) {    wchar_t* ptr = (wchar_t *)wcsstr(text->sentences[index]->symbols, word->symbols);    if(ptr == NULL)        return false;    if(ptr == text->sentences[index]->symbols){        int i = 0;        while(!isSentenceSeparator(text->sentences[index]->symbols[i]) &&              !isEndingOfSentence(text->sentences[index]->symbols[i]) &&               i < text->sentences[index]->size)            i++;        if(i < text->sentences[index]->size)            return true;    }    else {        if(isSentenceSeparator(*(ptr-1))){            int i = 0;            while(i < word->size && ptr < &(text->sentences[index]->symbols[text->sentences[index]->size - 1]) && *ptr == word->symbols[i])                i++;            if(i == text->sentences[index]->size)                return true;        }    }    return false;}void checkWordUnique(Text_t *text, Sentence_t *word, Text_t *ansText, size_t i) {    bool flag = true;    for(size_t k = 0; k < text->size; k++) {        if(k != i) {            if(check(text, word, k)){                flag = (flag * false);            }        } else {            flag = (flag * !isWordInSentence(text->sentences[k], word));        }    }    if(flag) {        addSentenceToText(ansText, word);    } else {        freeSentence(word);    }}Sentence_t* updateSentenceDate(Sentence_t *sentence, size_t index, wchar_t* date) {    Sentence_t* newSentence = (Sentence_t*)malloc(sizeof(Sentence_t));    initSentence(newSentence);    for(size_t i = 0; i < index; i++) {        addSymbolToSentence(newSentence, sentence->symbols[i]);    }    for (size_t i = 0; i < wcslen(date); i++) {        addSymbolToSentence(newSentence, date[i]);    }    while(sentence->symbols[index]!= L'г' && sentence->symbols[index + 1]!= L'.') {        index++;    }    index -= 5;    int k = 0;    while(k < 4) {        k++;        addSymbolToSentence(newSentence, sentence->symbols[index]);        index++;    }    addSymbolToSentence(newSentence, L'.');    addSymbolToSentence(newSentence, L'\0');    freeSentence(sentence);    updateSentenceProduct(newSentence);    return newSentence;}bool checkDate(Sentence_t *sentence, size_t index, wchar_t date[12]) {    int day = (sentence->symbols[index] - L'0');    if (iswdigit(sentence->symbols[index+1])) {        day = day * 10 + (sentence->symbols[index + 1] - L'0');    }    int maxDay = (date[0] - L'0') * 10 + (date[1] - L'0');    int flag = day < 10;    if (index > sentence->size - wcslen(date) - 7 - flag || sentence->size < wcslen(date) - 7 - flag)        return false;    //checkDay;    if (maxDay < day)        return false;    //checkMonth;    size_t i;    for (i = 2 - flag; i < wcslen(date); i++) {                if (sentence->symbols[index + i] != date[i])                    return false;    }    size_t k = 0;    //checkYear;    for (k = 0; k < 4; k ++) {        if(!iswdigit(sentence->symbols[index + i + k]))            return false;    }    wchar_t exampleYear[] = L" г.";    for (size_t y = 0; y < wcslen(exampleYear); y++) {        if (sentence->symbols[index + i + k + y] != exampleYear[y])            return false;    }    return true;}Sentence_t* foundDate(Sentence_t *sentence) {    wchar_t date[12][12] = {L"31 января ", L"29 февраля ",                            L"31 марта ", L"30 апреля ", L"31 мая ",                            L"30 июня ", L"31 июля ", L"31 августа ",                            L"30 сентября ", L"31 октября ", L"30 ноября ",                            L"31 декабря "};    for (size_t i = 0; i < sentence->size - 1; i++) {        if (i != 0) {            if (isSentenceSeparator(sentence->symbols[i - 1])) {                continue;            }        }        if (iswdigit(sentence->symbols[i]) && (iswdigit(sentence->symbols[i + 1]) || sentence->symbols[i+1] == L' ')) {            for(int m = 0; m < 12; m++) {                if (checkDate(sentence, i, date[m])) {                    wchar_t date[7];                    if (iswdigit(sentence->symbols[i + 1])) {                        date[0] = sentence->symbols[i];                        date[1] = sentence->symbols[i + 1];                    }                    else{                        date[0] = L'0';                        date[1] = sentence->symbols[i];                    }                    date[2] = L'/';                    if (m + 1 < 10) {                        date[3] = L'0';                        date[4] = m + 1 + L'0';                    }                    else {                        date[3] = L'1';                        date[4] = L'0' + ((m + 1) % 10);                    }                    date[5] = L'/';                    date[6] = L'\0';                    return updateSentenceDate(sentence, i, date);                }            }        }    }    return sentence;}void dateProcessing(Text_t* text) {    for(size_t i = 0; i < text->size; i++) {        text->sentences[i] = foundDate(text->sentences[i]);    }}void deleteSameSentence(Text_t *text) {    for (size_t i = 0; i < text->size - 1; i++) {        for (size_t j = i+1; j < text->size; j++) {            if (wcscasecmp(text->sentences[i]->symbols, text->sentences[j]->symbols) == 0) {                deleteSentences(text, j);                j--;            }        }    }}void printUniqueWords(Text_t* text, FILE* file) {    size_t i = 0;    size_t j = 0;    Text_t* ansText = (Text_t*)malloc(sizeof(Text_t));    initText(ansText);    while(i < text->size) {        Sentence_t* word = getWord(text, &i, &j);        checkWordUnique(text, word, ansText, i);    }    printText(ansText, file);    freeText(ansText);}void freeText(Text_t* text) {    for (size_t i = 0; i < text->size; i++) {        freeSentence(text->sentences[i]);    }    free(text->sentences);    free(text);}